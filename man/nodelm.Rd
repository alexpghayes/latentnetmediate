% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/nodelm.R
\name{nodelm}
\alias{nodelm}
\title{Use spectral node embeddings in ordinary least squares regression}
\usage{
nodelm(formula, graph = NULL, data = NULL, attr = NULL, ...)
}
\arguments{
\item{formula}{A regression formula that can include \link{ase_specials}
and \link{vsp_specials}, which encode node embeddings. Data for non-
embedding terms can come from the global environment, \code{data}, or
can be named attributes of an \code{igraph} object. It is likely most
convenient and intuitive to but nodal covariates in the \code{nodes} table
of a \code{\link[tidygraph:tbl_graph]{tidygraph::tbl_graph()}} object to expose nodal data. See \link{reddit},
\link{addhealth} and \link{smoking} for examples.}

\item{graph}{An optional \code{\link[igraph:make_graph]{igraph::graph()}} or \code{\link[tidygraph:tbl_graph]{tidygraph::tbl_graph()}}
object. If specified, the graph adjacency matrix \code{A}, normalized
graph Laplacian \code{L}, and regularized graph Laplacian \code{L_tau} are
injected into the environment of formula, so these matrices may be used
freely in \code{formula}. See \code{\link[igraph:as_adjacency_matrix]{igraph::as_adjacency_matrix()}} for
details about the construction of \code{A}, and
\code{\link[invertiforms:NormalizedLaplacian]{invertiforms::NormalizedLaplacian()}} and
\code{\link[invertiforms:RegularizedLaplacian]{invertiforms::RegularizedLaplacian()}} for details about the construction
of \code{L} and \code{L_tau}. Note that you can also use node embeddings based
on arbitrary matrix representations of a graph--see the examples.}

\item{data}{A \code{\link[=data.frame]{data.frame()}} with one row for each node in the graph.}

\item{attr}{Either \code{NULL} or a character string giving an edge
attribute name. If \code{NULL} a traditional adjacency matrix is returned.
If not \code{NULL} then the values of the given edge attribute are included
in the adjacency matrix. If the graph has multiple edges, the edge attribute
of an arbitrarily chosen edge (for the multiple edges) is included. This
argument is ignored if \code{edges} is \code{TRUE}.

Note that this works only for certain attribute types. If the \code{sparse}
argumen is \code{TRUE}, then the attribute must be either logical or
numeric. If the \code{sparse} argument is \code{FALSE}, then character is
also allowed. The reason for the difference is that the \code{Matrix}
package does not support character sparse matrices yet.}

\item{...}{
  Arguments passed on to \code{\link[stats:lm]{stats::lm}}
  \describe{
    \item{\code{subset}}{an optional vector specifying a subset of observations
    to be used in the fitting process.  (See additional details about how
    this argument interacts with data-dependent bases in the
    \sQuote{Details} section of the \code{\link[stats]{model.frame}}
    documentation.)}
    \item{\code{weights}}{an optional vector of weights to be used in the fitting
    process.  Should be \code{NULL} or a numeric vector.
    If non-NULL, weighted least squares is used with weights
    \code{weights} (that is, minimizing \code{sum(w*e^2)}); otherwise
    ordinary least squares is used.  See also \sQuote{Details},}
    \item{\code{na.action}}{a function which indicates what should happen
    when the data contain \code{NA}s.  The default is set by
    the \code{na.action} setting of \code{\link{options}}, and is
    \code{\link[stats]{na.fail}} if that is unset.  The \sQuote{factory-fresh}
    default is \code{\link[stats]{na.omit}}.  Another possible value is
    \code{NULL}, no action.  Value \code{\link[stats]{na.exclude}} can be useful.}
    \item{\code{method}}{the method to be used; for fitting, currently only
    \code{method = "qr"} is supported; \code{method = "model.frame"} returns
    the model frame (the same as with \code{model = TRUE}, see below).}
    \item{\code{model,x,y,qr}}{logicals.  If \code{TRUE} the corresponding
    components of the fit (the model frame, the model matrix, the
    response, the QR decomposition) are returned.
  }
    \item{\code{singular.ok}}{logical. If \code{FALSE} (the default in S but
    not in \R) a singular fit is an error.}
    \item{\code{contrasts}}{an optional list. See the \code{contrasts.arg}
    of \code{\link[stats]{model.matrix.default}}.}
    \item{\code{offset}}{this can be used to specify an \emph{a priori} known
    component to be included in the linear predictor during fitting.
    This should be \code{NULL} or a numeric vector or matrix of extents
    matching those of the response.  One or more \code{\link[stats]{offset}} terms can be
    included in the formula instead or as well, and if more than one are
    specified their sum is used.  See \code{\link[stats]{model.offset}}.}
  }}
}
\value{
An object of class \code{lm}. See \code{\link[stats:lm]{stats::lm()}} for
details.
}
\description{
A helper function that exposes the adjacency matrix \code{A}, normalized
graph Laplacian \code{L}, and regularized graph Laplacian \code{L_tau} to
model formulas for convenient network regression. Primarily designed
to work with \code{\link[tidygraph:tbl_graph]{tidygraph::tbl_graph()}} objects, but can also be used
with a matrix representation of a graph together with a \code{\link[=data.frame]{data.frame()}}
of nodal covariates.
}
\examples{

data(addhealth, package = "latentnetmediate")
data(smoking, package = "latentnetmediate")

### some examples where data is specified as a tidygraph

# a regression that does not use any node embeddings
nodelm(grade ~ sex, graph = addhealth[[36]])

# a regression including left and right singular embeddings of
# the adjacency matrix and the normalized graph Laplacian
nodelm(grade ~ sex + U(A, 5) + V(L, 3), graph = addhealth[[36]])

nodelm(as.integer(smokes) ~ sex + U(A, 5) , graph = smoking)

library(Matrix)
library(tidygraph)

B <- igraph::as_adjacency_matrix(addhealth[[36]], attr = "weight")

node <- addhealth[[36]] |>
  as_tibble() |>
  mutate(level = rowSums(B))

node[5, "sex"] <- NA
node

fit <- nodelm(level ~ sex + grade + race + U(sign(B), 10), data = node)
summary(fit)

}
